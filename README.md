# 前端套件管理工具介紹分享

### What and Why?

開發網站時，使用別人開發的套件工具輔助是很正常的一件事，很早以前剛學習時，最常使用[cdn](https://cdnjs.com/)的方式引入，或者是直接下載到專案放到某個資料夾裡；但久而久之也會衍伸許多問題，比如：版本的變更導致要重新手動連結新版本的cdn或是重新下載一包更版的套件。

框架的盛行是現今前端開發者幾乎都在使用的，上述的外部套件工具也只需透過指令下載，稍加設定就可以使用，上述問題也能透過一行指令解決，[npm](https://www.npmjs.com/)就是其中一種套件管理工具，也是最開始有這概念的工具，可稱鼻祖！

### 背後機制？

相信大家都一定有執行npm install的經驗，若是遇到大專案，常常會等到天荒地老，那背後機制是什麼？為什麼會那麼久？

以npm為例，將install的過程拆成五步驟，各家套件(ex: [Yarn](https://yarnpkg.com/))會略有不同，但通常都會經過這些階段：

##### 1. 計算缺少的套件
會先從專案中的三個地方計算出本次 install 需要重新下載安裝的內容，分別為以下三支檔案
* node_modules
* package.json
* package-lock.json | yarn.lock

##### 2.  從 Registry 取得套件資訊
計算完之後會向指定的 Registry拿到各套件需要下載的版本。

##### 3.  計算差異
由於套件本身也是專案，也可能引用其他套件；在這步驟會去計算各套件的 package.json，整理各套件個別需要下載的版本最後產出整個專案所使用的package-lock.json

##### 4. 下載、提取真正需要的套件
有了前面步驟的整理，接著就開始下載，然後解壓縮，提取到 node_modules；這裡會花最長時間且最耗效能；為了解決等很久的問題，npm本身其實也擁有快取機制，會同時寫入到電腦本機快取中，未來如果有其他專案需要用到同一個版本的套件，npm 會向 Registry 確認版本未更新後，直接複製快取的套件到 node_modules。
[image:B30029E6-98D1-4282-BFB5-99E7E99E2CD6-5342-00000CDF318C953F/1.jpeg]

##### 執行每個套件的 install。
檔案全部都寫入到 node_modules 後，npm 會執行所有套件的 npm install，讓套件本身的依賴被正確的連結到下載的套件上。

### 安全性問題

npm 在有快取的情況下，仍然不會使用同一份檔案，而是複製一份到 node_modules 中；也因為這樣的特性，加上套件依賴套件再依賴套件的層層相依，node_modules 非常容易莫名的塞好塞滿，長成誇張的容量黑洞。
[image:446281E4-5D21-4826-BF11-14E6DC02F5EE-53814-00015AA831E2822F/5.jpeg]

除此之外，層層相依同時也帶來了風險，開發者很容易在不知情中安裝了有風險，甚至含有惡意程式的套件。

### npm 結構的演變

```
node_modules
└─ foo
   ├─ index.js
   ├─ package.json
   └─ node_modules
      └─ bar
         ├─ index.js
         └─ package.json
```

```
node_modules
├─ foo
|  ├─ index.js
|  └─ package.json
└─ bar
   ├─ index.js
   └─ package.json
```


### npm vs yarn vs pnpm 

**npm**
 算是套件管理工具的鼻祖，應該就是。

**Yarn** 
為了解决 npm當時存在的一致性、安全性和性能的問題，Facebook集結了Google等等的一些公司開發的新套件管理工具。最明顯的就是，當時npm(v3)並沒有lock的機制，導致每個人下載的依賴會不同版本，Yarn使用了lock機制，解決了npm這個非常大的痛點，但之後npm(v5)也抄了這個功能。

雖說現在與npm都有lock機制，但npm是使用JSON的格式管理，Yarn則是自己發明了一個lock格式做管理，兩者之間的差別還有待研究。

Yarn 可以平行處理這上述的每個操作，讓整個安裝流程更快速，且多個執行的指令之間不會互相干擾。

[**pnpm**](https://pnpm.io/)

pnpm 基於內容尋址的文件系統來存取所有會用到的文件，跟上述不太一樣的事情是他存的是套件位置，而不是整包套件。

### 背後機制

##### node_modules 結構的不同

pnpm的node_modules並不是扁平化結構，而是目錄樹的結構，類似npm 2.x 中的結構。
node_modules還有個資料夾是.pnpm(虛擬儲存目錄)，以平鋪的形式儲存着所有的套件，正常的包都可以在這種命名模式的文件夾中被找到。

pnpm資源在磁盤上的存儲位置，官方稱之為Store。
pnpm 對項目安裝deps的時候，如果某個dep在 Store 目錄中存在了話，那麼就會直接從 Store 目錄裏面去 hard-link，避免了二次安裝帶來的時間消耗，如果依賴在 Store 目錄裏面不存在的話，就會去下載一次。

##### hard link 硬連接
使用者可以通過不同的路徑引用方式去找到某個檔案。

舉個例子，例如專案裡面有個 1MB 的依賴 a，在 pnpm 中，看上去這個 a 依賴同時佔用了 1MB 的 node_modules 目錄以及全域性  Store  目錄 1MB 的空間(加起來是 2MB)，但因為 hard link 的機制使得兩個目錄下相同的 1MB 空間能從兩個不同位置進行定址，因此實際上這個 a 依賴只用佔用 1MB 的空間，而不是 2MB。

因爲這樣一個機制，導致每次安裝依賴的時候，如果是個相同的依賴，有好多項目都用到這個依賴，那麼這個依賴實際上最優情況 (即版本相同) 只用安裝一次。

## 安全性高
之前在使用 npm/yarn 的時候，由於 node_module 的扁平結構，如果 A 依賴 B， B 依賴 C，那麼 A 當中是可以直接使用 C 的，但問題是 A 當中並沒有聲明 C 這個依賴。因此會出現這種非法訪問的情況。但 pnpm 自創了一套依賴管理方式，很好地解決了這個問題。

### 實測截圖
> [Benchmarks of JavaScript Package Managers | pnpm](https://pnpm.io/benchmarks)
[image:D60CB562-310B-4683-A30C-EA3D377E496A-5342-000063E955042936/截圖 2022-05-26 18.36.40.png]

[image:38AA3671-D881-4F58-A639-0184BF2C6D5F-5342-000063E95553AFF0/截圖 2022-05-26 18.37.45.png]
[image:C602048B-EA83-4CC5-B64B-948182582174-5342-0000640D687496DB/截圖 2022-05-26 18.45.35.png]

[image:8361D6B0-080A-4138-917A-9DC720840FFC-5342-000063E955B3D4AE/截圖 2022-05-26 18.42.31.png]
> 體感大約10秒左右。XD


### 延伸閱讀

##### npx  vs npm vs nvm ?
npx通常會跟npm拿來比較，npm 會全局性的安裝，也會一直存在在你的本機 node_modules 下；npx 會安裝在臨時安裝包上，等到項目初始化完成後就刪除。
nvm 是 Node.js 的版本管理器。

##### yarn pnp模式 (berry) ? 
為了減少node module容量超大東西超多的問題，進而衍伸出的一種新的方式，這個方式不會有node module資料夾，取而代之的是用一個靜態對映表來查找該套件在全局的位置進而使用。

---

[image:64787108-0BB8-4CFC-8C0B-0CA112E80A38-5342-0000642DEB4659D5/6.jpeg]



### References
…